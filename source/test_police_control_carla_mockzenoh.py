import carla
import time
import random
import math
import zenoh
import json
import threading
def calculate_surround_positions(truck, prediction_time=3.0):
    """
    üöî Ìä∏Îü≠ Ìè¨ÏúÑ ÏûëÏ†Ñ: 4ÎåÄÏùò Í≤ΩÏ∞∞Ï∞®Í∞Ä Ìä∏Îü≠ÏùÑ ÎëòÎü¨Ïã∏Îäî ÏúÑÏπò Í≥ÑÏÇ∞
    Args:
        truck: CARLA Vehicle Í∞ùÏ≤¥
        prediction_time: ÏòàÏ∏°Ìï† ÏãúÍ∞Ñ (Ï¥à)
    Returns:
        list: 4Í∞úÏùò Ìè¨ÏúÑ ÏúÑÏπò [Ïïû, Îí§, Ï¢å, Ïö∞]
    """
    current_loc = truck.get_location()
    velocity = truck.get_velocity()
    
    # Ìä∏Îü≠ ÏòàÏ∏° ÏúÑÏπò Í≥ÑÏÇ∞
    predicted_x = current_loc.x + velocity.x * prediction_time
    predicted_y = current_loc.y + velocity.y * prediction_time
    predicted_z = current_loc.z
    predicted_loc = carla.Location(x=predicted_x, y=predicted_y, z=predicted_z)
    
    # Ìä∏Îü≠Ïùò ÏßÑÌñâ Î∞©Ìñ• Î≤°ÌÑ∞ Í≥ÑÏÇ∞
    truck_transform = truck.get_transform()
    forward_vector = truck_transform.get_forward_vector()
    right_vector = truck_transform.get_right_vector()
    
    # Ìè¨ÏúÑ Í±∞Î¶¨ ÏÑ§Ï†ï (ÎèôÏ†Å Ï°∞Ï†ï)
    truck_speed = math.sqrt(velocity.x**2 + velocity.y**2)
    # Ìä∏Îü≠ ÏÜçÎèÑÏóê Îî∞Îùº Ìè¨ÏúÑ Í±∞Î¶¨ Ï°∞Ï†ï (Îπ†Î•ºÏàòÎ°ù Î©ÄÎ¶¨, ÎäêÎ¶¥ÏàòÎ°ù Í∞ÄÍπùÍ≤å)
    base_distance = 20.0
    speed_factor = max(0.5, min(2.0, truck_speed / 10.0))  # 0.5~2.0Î∞∞ Ï°∞Ï†ï
    surround_distance = base_distance * speed_factor
    
    print(f"[Surround] Ìä∏Îü≠ ÏÜçÎèÑ: {truck_speed:.1f}m/s, Ìè¨ÏúÑ Í±∞Î¶¨: {surround_distance:.1f}m")
    
    # üöî 4Î∞©Ìñ• Ìè¨ÏúÑ ÏúÑÏπò Í≥ÑÏÇ∞
    positions = []
    
    # 1. Ï†ÑÎ∞© (Ìä∏Îü≠ ÏßÑÌñâÎ∞©Ìñ• ÏïûÏ™Ω)
    front_pos = carla.Location(
        x=predicted_loc.x + forward_vector.x * surround_distance,
        y=predicted_loc.y + forward_vector.y * surround_distance,
        z=predicted_loc.z
    )
    positions.append(front_pos)
    
    # 2. ÌõÑÎ∞© (Ìä∏Îü≠ ÏßÑÌñâÎ∞©Ìñ• Îí§Ï™Ω)
    rear_pos = carla.Location(
        x=predicted_loc.x - forward_vector.x * surround_distance,
        y=predicted_loc.y - forward_vector.y * surround_distance,
        z=predicted_loc.z
    )
    positions.append(rear_pos)
    
    # 3. Ï¢åÏ∏° (Ìä∏Îü≠ Í∏∞Ï§Ä ÏôºÏ™Ω)
    left_pos = carla.Location(
        x=predicted_loc.x - right_vector.x * surround_distance,
        y=predicted_loc.y - right_vector.y * surround_distance,
        z=predicted_loc.z
    )
    positions.append(left_pos)
    
    # 4. Ïö∞Ï∏° (Ìä∏Îü≠ Í∏∞Ï§Ä Ïò§Î•∏Ï™Ω)
    right_pos = carla.Location(
        x=predicted_loc.x + right_vector.x * surround_distance,
        y=predicted_loc.y + right_vector.y * surround_distance,
        z=predicted_loc.z
    )
    positions.append(right_pos)
    
    return positions

def visualize_planner_route(world, route, life_time=5.0):
    for loc in route:
        carla_loc = carla.Location(x=loc[0], y=loc[1], z=loc[2] + 0.5)
        world.debug.draw_string(
            carla_loc,
            "O",
            draw_shadow=False,
            color=carla.Color(0, 255, 0),
            life_time=life_time,
            persistent_lines=True,
        )
from controllers.pid_longitudinal import PIDLongitudinalController
from controllers.stanley_lateral import StanleyLateralController
from controllers.vehicle_unstuck import VehicleUnstuck
from state.police_state import PoliceState
from waypoints.chase_planner import ChasePlanner
from waypoints.waypoint_manager import WaypointManager

CARLA_HOST = "localhost"
CARLA_PORT = 2000
CONTROL_DT = 0.05
MAX_BRAKE = 1.0
MAX_THROTTLE = 1.0
TARGET_SPEED = 15.0
NUM_POLICE = 4

# ---------- REAL ZENOH INTEGRATION ----------
class ZenohPoliceInterface:
    def __init__(self):
        self.session = None
        self.lockon_cb = None
        self.target_location_cb = None
        self.latest_target_location = None
        self.lock = threading.Lock()
        
        # Initialize Zenoh session
        try:
            config = zenoh.Config()
            self.session = zenoh.open(config)
            print("[ZenohPoliceInterface] ‚úÖ Connected to Zenoh network")
        except Exception as e:
            print(f"[ZenohPoliceInterface] ‚ùå Failed to connect to Zenoh: {e}")
            self.session = None

    def subscribe_lockon(self, cb):
        """Subscribe to lock-on signals from chase police team"""
        self.lockon_cb = cb
        if self.session:
            try:
                # Subscribe to emergency/pursuit signals
                sub = self.session.declare_subscriber(
                    "police/emergency/lockon", 
                    self._handle_lockon_signal
                )
                print("[ZenohPoliceInterface] üì° Subscribed to police/emergency/lockon")
            except Exception as e:
                print(f"[ZenohPoliceInterface] ‚ùå Failed to subscribe lockon: {e}")

    def subscribe_target_location(self, cb):
        """Subscribe to target vehicle location from chase police team"""
        self.target_location_cb = cb
        if self.session:
            try:
                # Subscribe to target vehicle VSS data
                sub = self.session.declare_subscriber(
                    "police/target/location", 
                    self._handle_target_location
                )
                print("[ZenohPoliceInterface] üì° Subscribed to police/target/location")
                
                # Also subscribe to VSS vehicle position data
                sub_vss = self.session.declare_subscriber(
                    "vehicle/currentlocation", 
                    self._handle_vss_location
                )
                print("[ZenohPoliceInterface] üì° Subscribed to vehicle/currentlocation")
            except Exception as e:
                print(f"[ZenohPoliceInterface] ‚ùå Failed to subscribe target location: {e}")

    def _handle_lockon_signal(self, sample):
        """Handle incoming lock-on signals"""
        try:
            data = json.loads(sample.payload.decode('utf-8'))
            lockon_status = data.get('lockon', False)
            
            print(f"[ZenohPoliceInterface] üö® Lock-on signal received: {lockon_status}")
            
            if self.lockon_cb:
                self.lockon_cb(lockon_status)
                
        except Exception as e:
            print(f"[ZenohPoliceInterface] ‚ùå Error handling lockon signal: {e}")

    def _handle_target_location(self, sample):
        """Handle target vehicle location updates"""
        try:
            data = json.loads(sample.payload.decode('utf-8'))
            
            # Extract coordinates from the data
            x = data.get('x', 0.0)
            y = data.get('y', 0.0) 
            z = data.get('z', 0.0)
            
            with self.lock:
                self.latest_target_location = carla.Location(x=x, y=y, z=z)
            
            print(f"[ZenohPoliceInterface] üéØ Target location updated: ({x:.2f}, {y:.2f}, {z:.2f})")
            
            if self.target_location_cb:
                self.target_location_cb(self.latest_target_location)
                
        except Exception as e:
            print(f"[ZenohPoliceInterface] ‚ùå Error handling target location: {e}")

    def _handle_vss_location(self, sample):
        """Handle VSS vehicle location data"""
        try:
            data = json.loads(sample.payload.decode('utf-8'))
            
            # VSS format: Vehicle.CurrentLocation.Latitude/Longitude
            if 'CurrentLocation' in data:
                # Convert GPS to CARLA coordinates (simplified)
                lat = data['CurrentLocation'].get('Latitude', 0.0)
                lon = data['CurrentLocation'].get('Longitude', 0.0)
                alt = data['CurrentLocation'].get('Altitude', 0.0)
                
                # Simple GPS to CARLA coordinate conversion
                # (In real implementation, use proper GPS->UTM->CARLA conversion)
                x = (lon + 180) * 1000  # Simplified conversion
                y = (lat + 90) * 1000   # Simplified conversion
                z = alt
                
                with self.lock:
                    self.latest_target_location = carla.Location(x=x, y=y, z=z)
                
                print(f"[ZenohPoliceInterface] üåç VSS location: GPS({lat:.6f}, {lon:.6f}) ‚Üí CARLA({x:.2f}, {y:.2f})")
                
                if self.target_location_cb:
                    self.target_location_cb(self.latest_target_location)
                    
        except Exception as e:
            print(f"[ZenohPoliceInterface] ‚ùå Error handling VSS location: {e}")

    def get_latest_target_location(self):
        """Get the most recent target location"""
        with self.lock:
            return self.latest_target_location

    def publish_encirclement_status(self, police_positions, target_location):
        """Publish encirclement status back to the network"""
        if not self.session:
            return
            
        try:
            status_data = {
                "timestamp": time.time(),
                "target_location": {
                    "x": target_location.x,
                    "y": target_location.y,
                    "z": target_location.z
                },
                "police_units": []
            }
            
            for i, pos in enumerate(police_positions):
                police_data = {
                    "unit_id": f"ENCIRCLE-{i:03d}",
                    "position": {
                        "x": pos.x,
                        "y": pos.y, 
                        "z": pos.z
                    },
                    "role": ["FRONT", "REAR", "LEFT", "RIGHT"][i % 4]
                }
                status_data["police_units"].append(police_data)
            
            # Publish encirclement status
            self.session.put(
                "police/encirclement/status", 
                json.dumps(status_data).encode('utf-8')
            )
            
            print(f"[ZenohPoliceInterface] üì§ Published encirclement status: {len(police_positions)} units")
            
        except Exception as e:
            print(f"[ZenohPoliceInterface] ‚ùå Error publishing status: {e}")

    def close(self):
        """Clean up Zenoh connection"""
        if self.session:
            self.session.close()
            print("[ZenohPoliceInterface] üîå Zenoh session closed")


# ---------- CARLA HELPERS ----------
def connect_carla(host=CARLA_HOST, port=CARLA_PORT, timeout=10.0):
    client = carla.Client(host, port)
    client.set_timeout(timeout)
    world = client.get_world()
    return client, world

def spawn_police_vehicle(world, spawn_point):
    blueprint_library = world.get_blueprint_library()
    police_candidates = [
        "vehicle.dodge.charger_police_2020",
        "vehicle.dodge.charger_police",
        "vehicle.crown.crown_police"
    ]
    police_bp = None
    for cand in police_candidates:
        bps = blueprint_library.filter(cand)
        if bps:
            police_bp = bps[0]
            police_bp.set_attribute("role_name", "police")
            break
    if not police_bp:
        police_bp = blueprint_library.find("vehicle.tesla.model3")
    vehicle = world.spawn_actor(police_bp, spawn_point)
    return vehicle

def spawn_truck(world, spawn_point):
    """Ìä∏Îü≠ÏùÑ Ïä§Ìè∞ÌïòÍ≥† autopilot Î™®ÎìúÎ°ú ÏÑ§Ï†ï"""
    blueprint_library = world.get_blueprint_library()
    truck_candidates = [
        "vehicle.carlamotors.carlacola",
        "vehicle.tesla.cybertruck",
        "vehicle.carlamotors.firetruck"
    ]
    truck_bp = None
    for cand in truck_candidates:
        bps = blueprint_library.filter(cand)
        if bps:
            truck_bp = bps[0]
            truck_bp.set_attribute("role_name", "target_truck")
            print(f"[Truck] üöõ Ìä∏Îü≠ Î∏îÎ£®ÌîÑÎ¶∞Ìä∏ ÏÇ¨Ïö©: {cand}")
            break
    if not truck_bp:
        truck_bp = blueprint_library.find("vehicle.volkswagen.t2")
    
    truck = world.spawn_actor(truck_bp, spawn_point)
    truck.set_autopilot(True)  # Ìä∏Îü≠ÏùÄ autopilotÏúºÎ°ú ÎèåÏïÑÎã§Îãò
    print(f"[Truck] Ìä∏Îü≠Ïù¥ autopilot Î™®ÎìúÎ°ú Ïä§Ìè∞Îê®: {spawn_point}")
    return truck

# ---------- MAIN ----------
def main():
    client, world = connect_carla()
    available_spawn_points = world.get_map().get_spawn_points()
    print(f"[System] ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Ïä§Ìè∞ Ìè¨Ïù∏Ìä∏: {len(available_spawn_points)}Í∞ú")
    
    if len(available_spawn_points) < NUM_POLICE + 1:
        print(f"[Error] Ïä§Ìè∞ Ìè¨Ïù∏Ìä∏Í∞Ä Î∂ÄÏ°±Ìï©ÎãàÎã§. ÌïÑÏöî: {NUM_POLICE + 1}, ÏÇ¨Ïö©Í∞ÄÎä•: {len(available_spawn_points)}")
        return
    
    random.shuffle(available_spawn_points)  # ÎûúÎç§ ÏÑûÍ∏∞

    # 4ÎåÄ Í≤ΩÏ∞∞Ï∞® ÏÉùÏÑ± (ÏÑúÎ°ú Îã§Î•∏ ÏúÑÏπò)
    police_vehicles = []
    for i in range(NUM_POLICE):
        spawn_point = available_spawn_points[i]
        print(f"[System] Police {i} Ïä§Ìè∞ ÏãúÎèÑ: {spawn_point}")
        ego = spawn_police_vehicle(world, spawn_point)
        actual_transform = ego.get_transform()
        print(f"[CARLA] Police vehicle {i} spawned at: {actual_transform}")
        police_vehicles.append({
            'vehicle': ego,
            'pid': PIDLongitudinalController(kp=0.4, ki=0.02, kd=0.08, dt=CONTROL_DT),
            'stanley': StanleyLateralController(),
            'state': PoliceState(),
            'wpm': WaypointManager(),
            'planner': ChasePlanner(world, sampling_resolution=1.0),
            'unstuck': VehicleUnstuck()
        })

    # üöõ Ìä∏Îü≠ Ïä§Ìè∞ (Í≤ΩÏ∞∞Ï∞®Îì§Í≥º Îã§Î•∏ ÏúÑÏπò)
    truck_spawn = available_spawn_points[NUM_POLICE]  
    truck = spawn_truck(world, truck_spawn)
    
    # ÌÉÄÏù¥Î∞ç Í¥ÄÎ†® Î≥ÄÏàòÎì§
    PATROL_DURATION = 5.0        # ÏàúÏ∞∞ 5Ï¥à
    ROUTE_UPDATE_CYCLE = 10.0     # 5Ï¥àÎ•º Ìïú Ï£ºÍ∏∞Î°ú Í≤ΩÎ°ú ÏóÖÎç∞Ïù¥Ìä∏
    POLICE_UPDATE_OFFSET = 1.25  # Í∞Å Í≤ΩÏ∞∞Ï∞®ÎßàÎã§ 1.25Ï¥àÏî© Í∞ÑÍ≤© (5Ï¥à/4ÎåÄ)
    start_time = time.time()
    last_updates = [0.0] * NUM_POLICE  # Í∞Å Í≤ΩÏ∞∞Ï∞®Î≥Ñ ÎßàÏßÄÎßâ ÏóÖÎç∞Ïù¥Ìä∏ ÏãúÍ∞Ñ
    
    # Ìä∏Îü≠ ÏÉÅÌÉú Í¥ÄÎ¶¨
    truck_captured = False       # Ìä∏Îü≠ Ìè¨Ìöç Ïó¨Î∂Ä
    CAPTURE_DISTANCE = 10.0      # Ìè¨Ìöç Í±∞Î¶¨ (ÎØ∏ÌÑ∞)

    # Real Zenoh Integration
    zen = ZenohPoliceInterface()
    chase_mode_activated = False  # ÌïúÎ≤à ÌôúÏÑ±ÌôîÎêòÎ©¥ Í≥ÑÏÜç Ïú†ÏßÄ
    initial_chase_setup = False   # Ï≤´ Ï∂îÍ≤© Í≤ΩÎ°ú ÏÑ§Ï†ï Ïó¨Î∂Ä
    lockon_time = None
    
    # Dynamic target tracking
    dynamic_target_location = None
    target_lock = threading.Lock()

    # Zenoh callbacks
    def lockon_cb(val):
        nonlocal chase_mode_activated, initial_chase_setup, lockon_time
        if bool(val) and not chase_mode_activated:
            chase_mode_activated = True  # ÌïúÎ≤à TrueÍ∞Ä ÎêòÎ©¥ Í≥ÑÏÜç Ïú†ÏßÄ
            initial_chase_setup = False  # Ï≤´ Ï∂îÍ≤© Í≤ΩÎ°ú ÏÑ§Ï†ï ÎåÄÍ∏∞
            lockon_time = time.time()
            for p in police_vehicles:
                p['state'].lockon = True
            print("[System] üö® Ï∂îÍ≤© Î™®Îìú ÌôúÏÑ±Ìôî! Î™®Îì† Í≤ΩÏ∞∞Ï∞®Í∞Ä ÎèôÏãúÏóê Í≤ΩÎ°ú ÏÉùÏÑ± Ï§ë...")
        elif chase_mode_activated:
            # Ïù¥ÎØ∏ Ï∂îÍ≤©Î™®ÎìúÎ©¥ ÏÉÅÌÉú Ïú†ÏßÄ
            for p in police_vehicles:
                p['state'].lockon = True

    def target_location_cb(target_loc):
        """Handle dynamic target location updates from Zenoh"""
        nonlocal dynamic_target_location
        with target_lock:
            dynamic_target_location = target_loc
        print(f"[System] üéØ Dynamic target location updated: ({target_loc.x:.2f}, {target_loc.y:.2f}, {target_loc.z:.2f})")

    # Subscribe to Zenoh topics
    zen.subscribe_lockon(lockon_cb)
    zen.subscribe_target_location(target_location_cb)

    print("[System] üöî Í≤ΩÏ∞∞Ï∞®Îì§Ïù¥ 5Ï¥àÍ∞Ñ ÏàúÏ∞∞ Î™®ÎìúÎ°ú ÏãúÏûëÌï©ÎãàÎã§...")
    print("[System] üöõ Ìä∏Îü≠Ïù¥ autopilotÏúºÎ°ú ÎèåÏïÑÎã§ÎãàÍ≥† ÏûàÏäµÎãàÎã§...")

    try:
        while True:
            loop_start = time.time()
            now = time.time()
            
            # Ï∞®Îüâ ÏÉùÏ°¥ ÏÉÅÌÉú ÌôïÏù∏
            if not all(p['vehicle'].is_alive for p in police_vehicles) or not truck.is_alive:
                print("[Error] Ï∞®ÎüâÏù¥ ÌååÍ¥¥ÎêòÏóàÏäµÎãàÎã§. ÏãúÎÆ¨Î†àÏù¥ÏÖòÏùÑ Ï¢ÖÎ£åÌï©ÎãàÎã§.")
                break

            # üö® 5Ï¥à ÌõÑ ÏûêÎèô lockon Ïã†Ìò∏ Î∞úÏÉù
            if not chase_mode_activated and (now - start_time) > PATROL_DURATION:
                print("[System] ‚ö° 5Ï¥à Í≤ΩÍ≥º! Ìä∏Îü≠ Ï∂îÏ†Å Î™®Îìú ÏãúÏûë!")
                lockon_cb(True)
                
            # üöõ Ìä∏Îü≠ autopilot ÏÉÅÌÉú Ïú†ÏßÄ (Ìè¨ÌöçÎêòÏßÄ ÏïäÏïòÏùÑ ÎïåÎßå)
            if not truck_captured and int(now * 10) % 50 == 0:  # 5Ï¥àÎßàÎã§ ÌïúÎ≤àÏî© autopilot Ïû¨ÏÑ§Ï†ï
                truck.set_autopilot(True)
            elif truck_captured:
                # Ìè¨ÌöçÎêú ÏÉÅÌÉúÏóêÏÑúÎäî Ï†ïÏßÄ ÏÉÅÌÉú Ïú†ÏßÄ
                truck.apply_control(carla.VehicleControl(throttle=0.0, brake=1.0, steer=0.0))
            
            # üöõ Ìä∏Îü≠ ÏúÑÏπò ÏãúÍ∞ÅÌôî (Ï∂îÍ≤© Î™®ÎìúÏùº Îïå)
            if chase_mode_activated:
                truck_loc = truck.get_location()
                if truck_captured:
                    world.debug.draw_string(truck_loc + carla.Location(z=2.0), "üö® STOPPED", 
                                          draw_shadow=True, color=carla.Color(r=255, g=0, b=0),
                                          life_time=1.0, persistent_lines=False)
                else:
                    world.debug.draw_string(truck_loc + carla.Location(z=2.0), "üöõ TARGET", 
                                          draw_shadow=True, color=carla.Color(r=255, g=255, b=0),
                                          life_time=1.0, persistent_lines=False)
            
            # üö® Ï≤´ Ï∂îÍ≤© ÏãúÏûëÏãú Î™®Îì† Í≤ΩÏ∞∞Ï∞®Í∞Ä ÎèôÏ†Å Î™©Ï†ÅÏßÄ Ìè¨ÏúÑ ÏûëÏ†Ñ Í∞úÏãú!
            if chase_mode_activated and not initial_chase_setup and not truck_captured:
                print("[System] üöî ÎèôÏ†Å Î™©Ï†ÅÏßÄ Ìè¨ÏúÑ ÏûëÏ†Ñ Í∞úÏãú! 4ÎåÄÏùò Í≤ΩÏ∞∞Ï∞®Í∞Ä Ìè¨ÏúÑ ÏúÑÏπòÎ°ú Ïù¥Îèô Ï§ë...")
                
                # Use dynamic target location from Zenoh if available, otherwise use truck
                with target_lock:
                    if dynamic_target_location is not None:
                        target_loc = dynamic_target_location
                        print(f"[System] üéØ Using Zenoh target location: ({target_loc.x:.2f}, {target_loc.y:.2f})")
                    else:
                        target_loc = truck.get_location()
                        print("[System] üöõ Fallback to truck location (no Zenoh data)")
                
                # Create virtual truck object for calculate_surround_positions
                class VirtualTarget:
                    def __init__(self, location):
                        self._location = location
                        self._velocity = carla.Vector3D(0, 0, 0)  # Assume stationary for now
                        self._transform = carla.Transform(location, carla.Rotation())
                        
                    def get_location(self):
                        return self._location
                        
                    def get_velocity(self):
                        return self._velocity
                        
                    def get_transform(self):
                        return self._transform
                
                virtual_target = VirtualTarget(target_loc)
                surround_positions = calculate_surround_positions(virtual_target, prediction_time=3.0)
                
                # Ìè¨ÏúÑ ÏúÑÏπòÎì§ ÏãúÍ∞ÅÌôî
                position_names = ["üî¥ FRONT", "üîµ REAR", "üü¢ LEFT", "üü° RIGHT"]
                colors = [carla.Color(255, 0, 0), carla.Color(0, 0, 255), carla.Color(0, 255, 0), carla.Color(255, 255, 0)]
                
                for i, (pos, name, color) in enumerate(zip(surround_positions, position_names, colors)):
                    world.debug.draw_string(pos + carla.Location(z=3.0), 
                                          name, 
                                          draw_shadow=True, 
                                          color=color,
                                          life_time=8.0, persistent_lines=True)
                
                # Í∞Å Í≤ΩÏ∞∞Ï∞®Î•º Ìï¥Îãπ Ìè¨ÏúÑ ÏúÑÏπòÎ°ú Î∞∞Ïπò
                for idx, p in enumerate(police_vehicles):
                    origin = p['vehicle'].get_location()
                    target_position = surround_positions[idx % len(surround_positions)]  # 4Í∞ú ÏúÑÏπò ÏàúÌôò
                    
                    print(f"[Police-{idx}] üéØ {position_names[idx % len(position_names)]} Ìè¨ÏúÑ ÏúÑÏπòÎ°ú Ïù¥Îèô ÏãúÏûë!")
                    p['planner'].plan_route(origin, target_position)
                    route = p['planner'].get_route()
                    if route:
                        p['wpm'].set_waypoints([(x, y, z) for x, y, z in route])
                        visualize_planner_route(world, route, life_time=5.0)
                        print(f"[Police-{idx}] ‚úÖ Ìè¨ÏúÑ Í≤ΩÎ°ú ÏÉùÏÑ± ÏôÑÎ£å ({len(route)} waypoints)")
                    last_updates[idx] = now
                
                initial_chase_setup = True
                print("[System] üöî Ï†ÑÏ≤¥ Ìè¨ÏúÑ ÏûëÏ†Ñ Í≤ΩÎ°ú ÏÑ§Ï†ï ÏôÑÎ£å!")

            for idx, p in enumerate(police_vehicles):
                ego = p['vehicle']
                pid = p['pid']
                stanley = p['stanley']
                state = p['state']
                wpm = p['wpm']
                planner = p['planner']
                unstuck_module = p['unstuck']

                # Ï∞®Îüâ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
                trans = ego.get_transform()
                vel = ego.get_velocity()
                speed = math.sqrt(vel.x**2 + vel.y**2)
                state.update_from_carla_transform(trans, vel)

                # ÔøΩ ÎèôÏ†Å Î™©Ï†ÅÏßÄ Ìè¨ÏúÑ ÏôÑÏÑ± Î∞è Ìè¨Ìöç Í±∞Î¶¨ ÌôïÏù∏
                if chase_mode_activated and not truck_captured:
                    # Use dynamic target location if available
                    with target_lock:
                        if dynamic_target_location is not None:
                            target_loc = dynamic_target_location
                        else:
                            target_loc = truck.get_location()
                    
                    ego_loc = ego.get_location()
                    distance = math.hypot(target_loc.x - ego_loc.x, target_loc.y - ego_loc.y)
                    
                    # üéØ Ìè¨ÏúÑ ÏôÑÏÑ±ÎèÑ Ï≤¥ÌÅ¨ (Î™®Îì† Í≤ΩÏ∞∞Ï∞®Í∞Ä 30m Ïù¥ÎÇ¥Ïóê ÏûàÎäîÏßÄ)
                    all_distances = []
                    police_positions = []
                    for p_check in police_vehicles:
                        p_loc = p_check['vehicle'].get_location()
                        p_distance = math.hypot(target_loc.x - p_loc.x, target_loc.y - p_loc.y)
                        all_distances.append(p_distance)
                        police_positions.append(p_loc)
                    
                    surround_complete = all([d <= 30.0 for d in all_distances])
                    if surround_complete and idx == 0:  # Ï≤´ Î≤àÏß∏ Í≤ΩÏ∞∞Ï∞®ÏóêÏÑúÎßå Ï≤¥ÌÅ¨
                        world.debug.draw_string(target_loc + carla.Location(z=4.0), 
                                              "üöî SURROUNDED! üöî", 
                                              draw_shadow=True, 
                                              color=carla.Color(r=255, g=0, b=255),
                                              life_time=2.0, persistent_lines=False)
                        
                        # Publish encirclement status to Zenoh
                        zen.publish_encirclement_status(police_positions, target_loc)
                    
                    if distance <= CAPTURE_DISTANCE:
                        truck_captured = True
                        if truck.is_alive:  # Only control if truck exists
                            truck.set_autopilot(False)  # autopilot Ìï¥Ï†ú
                            truck.apply_control(carla.VehicleControl(throttle=0.0, brake=1.0, steer=0.0))
                        print(f"[SUCCESS] üéâ Police-{idx}Ïù¥ Î™©Ï†ÅÏßÄÎ•º Ìè¨ÌöçÌñàÏäµÎãàÎã§! (Í±∞Î¶¨: {distance:.1f}m)")
                        world.debug.draw_string(target_loc + carla.Location(z=3.0), "üö® CAPTURED!", 
                                              draw_shadow=True, color=carla.Color(r=255, g=0, b=0),
                                              life_time=30.0, persistent_lines=True)

                # ÔøΩ Ìè¨ÏúÑ Î™®ÎìúÏùº Îïå 5Ï¥à Ï£ºÍ∏∞Î°ú Í∞Å Í≤ΩÏ∞∞Ï∞®Î≥Ñ ÏàúÏ∞® Ìè¨ÏúÑ ÏúÑÏπò ÏóÖÎç∞Ïù¥Ìä∏ (ÎèôÏ†Å Î™©Ï†ÅÏßÄ Í∏∞Î∞ò)
                if chase_mode_activated and not truck_captured:
                    # Í∞Å Í≤ΩÏ∞∞Ï∞®ÎßàÎã§ Îã§Î•∏ ÏãúÍ∞ÑÏóê ÏóÖÎç∞Ïù¥Ìä∏ (0, 1.25, 2.5, 3.75Ï¥à)
                    chase_elapsed = (now - lockon_time) % ROUTE_UPDATE_CYCLE
                    police_update_time = idx * POLICE_UPDATE_OFFSET
                    
                    if abs(chase_elapsed - police_update_time) < 0.1 and (now - last_updates[idx]) >= (ROUTE_UPDATE_CYCLE - 0.2):
                        origin = ego.get_location()
                        
                        # üéØ ÎèôÏ†Å Î™©Ï†ÅÏßÄ Í∏∞Î∞ò Ìè¨ÏúÑ ÏúÑÏπò Ïû¨Í≥ÑÏÇ∞ (Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏)
                        with target_lock:
                            if dynamic_target_location is not None:
                                current_target_loc = dynamic_target_location
                            else:
                                current_target_loc = truck.get_location()
                        
                        # Create virtual target for current location
                        class VirtualTarget:
                            def __init__(self, location):
                                self._location = location
                                self._velocity = carla.Vector3D(0, 0, 0)
                                self._transform = carla.Transform(location, carla.Rotation())
                                
                            def get_location(self):
                                return self._location
                                
                            def get_velocity(self):
                                return self._velocity
                                
                            def get_transform(self):
                                return self._transform
                        
                        virtual_target = VirtualTarget(current_target_loc)
                        surround_positions = calculate_surround_positions(virtual_target, prediction_time=3.0)
                        target_position = surround_positions[idx % len(surround_positions)]
                        
                        # Ìè¨ÏúÑ ÏúÑÏπò ÏãúÍ∞ÅÌôî
                        position_names = ["üî¥ FRONT", "üîµ REAR", "üü¢ LEFT", "üü° RIGHT"]
                        position_colors = [carla.Color(255,0,0), carla.Color(0,0,255), carla.Color(0,255,0), carla.Color(255,255,0)]
                        
                        world.debug.draw_string(target_position + carla.Location(z=1.5), 
                                              f"{position_names[idx % len(position_names)]} P{idx}", 
                                              draw_shadow=True, 
                                              color=position_colors[idx % len(position_colors)],
                                              life_time=3.0, persistent_lines=False)
                        
                        planner.plan_route(origin, target_position)
                        route = planner.get_route()
                        if route:
                            wpm.set_waypoints([(x, y, z) for x, y, z in route])
                            visualize_planner_route(world, route, life_time=3.0)
                            print(f"[Police-{idx}] üöî {position_names[idx % len(position_names)]} Ìè¨ÏúÑ ÏúÑÏπò ÏóÖÎç∞Ïù¥Ìä∏ ÏôÑÎ£å")
                        last_updates[idx] = now

                # Unstuck Ï†ÅÏö©
                control_signal = ego.get_control()
                unstuck_module.check_stuck(control_signal.throttle, speed, ego.get_location(), CONTROL_DT)
                unstuck_control = unstuck_module.compute_unstuck_control(ego.get_location(), CONTROL_DT)
                if unstuck_control:
                    ego.apply_control(unstuck_control)
                    continue  # unstuck Ï§ëÏù¥Î©¥ PID/Stanley Ïä§ÌÇµ

                # üöî Í≤ΩÏ∞∞Ï∞® Î™®Îìú Ï†úÏñ¥: ÏàúÏ∞∞ vs Ï∂îÍ≤©
                if not chase_mode_activated:
                    # ÏàúÏ∞∞ Î™®Îìú: autopilot ÌôúÏÑ±Ìôî
                    ego.set_autopilot(True)
                    continue
                else:
                    # Ï∂îÍ≤© Î™®Îìú: ÏàòÎèô Ï†úÏñ¥
                    ego.set_autopilot(False)

                # ÌòÑÏû¨ Î™©Ìëú waypoint
                target = wpm.get_current_target()
                if target is None:
                    ego.apply_control(carla.VehicleControl(throttle=0.0, brake=MAX_BRAKE, steer=0.0))
                    continue

                tx, ty, tz = target
                steer = stanley.compute_steer(state.x, state.y, state.yaw,
                                              [(wp[0], wp[1]) for wp in wpm.waypoints],
                                              state.speed,
                                              lockon_time=lockon_time)
                pid_out = pid.run_step(TARGET_SPEED, state.speed, lockon_time=lockon_time)
                throttle = min(MAX_THROTTLE, pid_out) if pid_out >= 0 else 0.0
                brake = min(MAX_BRAKE, -pid_out) if pid_out < 0 else 0.0
                ego.apply_control(carla.VehicleControl(steer=float(steer), throttle=float(throttle), brake=float(brake)))
                wpm.update_progress(state.x, state.y)

                if wpm.is_final_reached(state.x, state.y):
                    ego.apply_control(carla.VehicleControl(throttle=0.0, brake=MAX_BRAKE, steer=0.0))

            # Î©îÏù∏ Î£®ÌîÑ Ï¢ÖÎ£å

            elapsed = time.time() - loop_start
            time.sleep(max(0.0, CONTROL_DT - elapsed))

    except KeyboardInterrupt:
        print("Shutting down police_control.")
    finally:
        # Zenoh Ïó∞Í≤∞ Ï†ïÎ¶¨
        zen.close()
        
        # Í≤ΩÏ∞∞Ï∞®Îì§ Ï†ïÎ¶¨
        for p in police_vehicles:
            if p['vehicle'].is_alive:
                p['vehicle'].destroy()
        print("All police vehicles destroyed safely.")
        
        # Ìä∏Îü≠ Ï†ïÎ¶¨
        if truck and truck.is_alive:
            truck.destroy()
        print("Target truck destroyed safely.")

if __name__ == "__main__":
    main()
